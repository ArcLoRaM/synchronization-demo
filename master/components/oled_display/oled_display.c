#include "oled_display.h"

#include "driver/i2c_master.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <string.h>
#include "esp_check.h"

#define TAG "oled_display"

// ---- Heltec WiFi LoRa V3 (ESP32-S3) pins ----
#define I2C_SDA_IO        17
#define I2C_SCL_IO        18
#define I2C_FREQ_HZ       400000
#define I2C_PORT_NUM      0
#define OLED_I2C_ADDR     0x3C
#define VEXT_PIN          36
#define OLED_RST_PIN      21

static i2c_master_bus_handle_t s_bus  = NULL;
static i2c_master_dev_handle_t s_dev  = NULL;
static bool s_initialized = false;

// ------------------ helpers ------------------
static inline esp_err_t oled_write_cmd(uint8_t cmd) {
    uint8_t buf[2] = { 0x00, cmd };                  // control=0x00 (command), then cmd
    return i2c_master_transmit(s_dev, buf, sizeof(buf), pdMS_TO_TICKS(100));
}





static inline esp_err_t oled_write_cmds(const uint8_t* cmds, size_t n) {
    if (!s_dev || !cmds || n == 0) {
        ESP_LOGE(TAG, "oled_write_cmds(): invalid args");
        return ESP_ERR_INVALID_ARG;
    }

    for (size_t i = 0; i < n; ++i) {
        vTaskDelay(pdMS_TO_TICKS(10)); // small delay between commands
        uint8_t buf[2] = { 0x00, cmds[i] };  // control=0x00 (command), then command byte
        esp_err_t err = ESP_FAIL;

        // --- retry loop with optional mutex in case of conflicts with lora module ---
        for (int attempt = 0; attempt < 3; ++attempt) {

            
            err = i2c_master_transmit(s_dev, buf, sizeof(buf), pdMS_TO_TICKS(100));

            if (err == ESP_OK) break; // success
           // ESP_LOGW(TAG, "I2C cmd 0x%02X failed (try %d)", cmds[i], attempt + 1);
            vTaskDelay(pdMS_TO_TICKS(10)); // short pause between retries
        }

        if (err != ESP_OK) {
            ESP_LOGE(TAG, "oled_write_cmds(): cmd 0x%02X failed after retries", cmds[i]);
            return err;
        }
    }

    return ESP_OK;
}




static inline esp_err_t oled_write_data(const uint8_t* data, size_t n) {
    // data must be sent with control byte 0x40 in the SAME transaction
    uint8_t buf[1 + 128];

    while (n) {
        size_t chunk = n > 128 ? 128 : n;
        buf[0] = 0x40;                               // control=0x40 (data)
        memcpy(&buf[1], data, chunk);

        // --- retry loop with optional mutex in case of conflicts with lora module ---
        esp_err_t err = ESP_FAIL;
        for (int attempt = 0; attempt < 3; ++attempt) {

            err = i2c_master_transmit(s_dev, buf, 1 + chunk, pdMS_TO_TICKS(200));

            if (err == ESP_OK) break;               // success
            ESP_LOGW(TAG, "I2C data xfer failed (try %d)", attempt + 1);
            vTaskDelay(pdMS_TO_TICKS(10));          // brief recovery delay
        }
        if (err != ESP_OK) {
            ESP_LOGE(TAG, "oled_write_data(): final fail after retries");
            return err;
        }

        data += chunk;
        n    -= chunk;
    }
    return ESP_OK;
}


static void oled_reset(void) {
    gpio_set_direction(OLED_RST_PIN, GPIO_MODE_OUTPUT);
    gpio_set_level(OLED_RST_PIN, 0);
    vTaskDelay(pdMS_TO_TICKS(10));
    gpio_set_level(OLED_RST_PIN, 1);
    vTaskDelay(pdMS_TO_TICKS(10));
}

void oled_vext_on(void) {
    gpio_set_direction(VEXT_PIN, GPIO_MODE_OUTPUT);
    gpio_set_level(VEXT_PIN, 0);   // LOW = ON
}

void oled_vext_off(void) {
    gpio_set_direction(VEXT_PIN, GPIO_MODE_OUTPUT);
    gpio_set_level(VEXT_PIN, 1);   // HIGH = OFF
}

// ------------------ public API ------------------
esp_err_t oled_init(void) {
    if (s_initialized) return ESP_OK;

    oled_vext_on();
    vTaskDelay(pdMS_TO_TICKS(300));
    oled_reset();
    vTaskDelay(pdMS_TO_TICKS(100));

    // v5.x I2C master bus (synchronous: trans_queue_depth = 0)
    i2c_master_bus_config_t bus_cfg = {
        .i2c_port = I2C_PORT_NUM,
        .sda_io_num = I2C_SDA_IO,
        .scl_io_num = I2C_SCL_IO,
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .glitch_ignore_cnt = 7,
        .intr_priority = 0,
        .trans_queue_depth = 0, // synchronous mode -> no async queue overflow
        .flags = {
            .enable_internal_pullup = true, // helps if the board lacks/has weak externals
        },
    };
    ESP_ERROR_CHECK(i2c_new_master_bus(&bus_cfg, &s_bus));

    i2c_device_config_t dev_cfg = {
        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
        .device_address  = OLED_I2C_ADDR,
        .scl_speed_hz    = I2C_FREQ_HZ,
    };
    ESP_ERROR_CHECK(i2c_master_bus_add_device(s_bus, &dev_cfg, &s_dev));

    // SSD1306 init sequence (128x64)
    const uint8_t init_seq[] = {
        0xAE,          // display off
        0x20, 0x00,    // memory addr mode: horizontal
        0x40,          // start line = 0
        0x81, 0x8F,    // contrast
        0xA1,          // segment remap
        0xA6,          // normal display (not inverted)
        0xA8, 0x3F,    // multiplex ratio 1/64
        0xC8,          // COM scan dir remapped
        0xD3, 0x00,    // display offset
        0xD5, 0x80,    // display clock
        0xD9, 0xF1,    // pre-charge
        0xDA, 0x12,    // COM pins
        0xDB, 0x40,    // VCOM detect
        0x8D, 0x14,    // charge pump on
        0xAF           // display on
    };
    ESP_ERROR_CHECK(oled_write_cmds(init_seq, sizeof(init_seq)));

    // Clear once after init to get rid of random garbage
    ESP_ERROR_CHECK(oled_clear());

    ESP_LOGI(TAG, "OLED initialized successfully");
    s_initialized = true;
    return ESP_OK;
}

esp_err_t oled_clear(void) {
    uint8_t zero[128] = {0};
    for (uint8_t page = 0; page < 8; ++page) {
        // set page & columns
        uint8_t addr_cmds[] = {
            0xB0 | page,  // page address
            0x00,         // lower column start
            0x10          // higher column start
        };
        ESP_RETURN_ON_ERROR(oled_write_cmds(addr_cmds, sizeof(addr_cmds)), TAG, "addr set failed");
        // write a full line (control+128 zeros in ONE transmit)
        ESP_RETURN_ON_ERROR(oled_write_data(zero, sizeof(zero)), TAG, "line clear failed");
    }
    return ESP_OK;
}

void oled_i2c_scan(void) {

    esp_err_t ret = i2c_master_probe(s_bus, 0x3C, pdMS_TO_TICKS(100));
if (ret == ESP_OK) {
    ESP_LOGI(TAG, "OLED found at 0x3C");
} else {
    ESP_LOGE(TAG, "OLED NOT found (err=0x%x)", ret);
}
}









// ---------------------------------------------------------
// Simple 6x8 ASCII font table (printable chars 32â€“127)
// Each byte = one row of 8 vertical pixels, LSB at top
// Source: public-domain 6x8 font used in many embedded demos
// ---------------------------------------------------------
static const uint8_t font6x8[][6] = {
{0x00,0x00,0x00,0x00,0x00,0x00}, // 32  
{0x00,0x00,0x5F,0x00,0x00,0x00}, // 33 !
{0x00,0x07,0x00,0x07,0x00,0x00}, // 34 "
{0x14,0x7F,0x14,0x7F,0x14,0x00}, // 35 #
{0x24,0x2A,0x7F,0x2A,0x12,0x00}, // 36 $
{0x23,0x13,0x08,0x64,0x62,0x00}, // 37 %
{0x36,0x49,0x55,0x22,0x50,0x00}, // 38 &
{0x00,0x05,0x03,0x00,0x00,0x00}, // 39 '
{0x00,0x1C,0x22,0x41,0x00,0x00}, // 40 (
{0x00,0x41,0x22,0x1C,0x00,0x00}, // 41 )
{0x14,0x08,0x3E,0x08,0x14,0x00}, // 42 *
{0x08,0x08,0x3E,0x08,0x08,0x00}, // 43 +
{0x00,0x50,0x30,0x00,0x00,0x00}, // 44 ,
{0x08,0x08,0x08,0x08,0x08,0x00}, // 45 -
{0x00,0x60,0x60,0x00,0x00,0x00}, // 46 .
{0x20,0x10,0x08,0x04,0x02,0x00}, // 47 /
{0x3E,0x51,0x49,0x45,0x3E,0x00}, // 48 0
{0x00,0x42,0x7F,0x40,0x00,0x00}, // 49 1
{0x42,0x61,0x51,0x49,0x46,0x00}, // 50 2
{0x21,0x41,0x45,0x4B,0x31,0x00}, // 51 3
{0x18,0x14,0x12,0x7F,0x10,0x00}, // 52 4
{0x27,0x45,0x45,0x45,0x39,0x00}, // 53 5
{0x3C,0x4A,0x49,0x49,0x30,0x00}, // 54 6
{0x01,0x71,0x09,0x05,0x03,0x00}, // 55 7
{0x36,0x49,0x49,0x49,0x36,0x00}, // 56 8
{0x06,0x49,0x49,0x29,0x1E,0x00}, // 57 9
{0x00,0x36,0x36,0x00,0x00,0x00}, // 58 :
{0x00,0x56,0x36,0x00,0x00,0x00}, // 59 ;
{0x08,0x14,0x22,0x41,0x00,0x00}, // 60 <
{0x14,0x14,0x14,0x14,0x14,0x00}, // 61 =
{0x00,0x41,0x22,0x14,0x08,0x00}, // 62 >
{0x02,0x01,0x51,0x09,0x06,0x00}, // 63 ?
{0x32,0x49,0x79,0x41,0x3E,0x00}, // 64 @
{0x7E,0x11,0x11,0x11,0x7E,0x00}, // 65 A
{0x7F,0x49,0x49,0x49,0x36,0x00}, // 66 B
{0x3E,0x41,0x41,0x41,0x22,0x00}, // 67 C
{0x7F,0x41,0x41,0x22,0x1C,0x00}, // 68 D
{0x7F,0x49,0x49,0x49,0x41,0x00}, // 69 E
{0x7F,0x09,0x09,0x09,0x01,0x00}, // 70 F
{0x3E,0x41,0x49,0x49,0x7A,0x00}, // 71 G
{0x7F,0x08,0x08,0x08,0x7F,0x00}, // 72 H
{0x00,0x41,0x7F,0x41,0x00,0x00}, // 73 I
{0x20,0x40,0x41,0x3F,0x01,0x00}, // 74 J
{0x7F,0x08,0x14,0x22,0x41,0x00}, // 75 K
{0x7F,0x40,0x40,0x40,0x40,0x00}, // 76 L
{0x7F,0x02,0x0C,0x02,0x7F,0x00}, // 77 M
{0x7F,0x04,0x08,0x10,0x7F,0x00}, // 78 N
{0x3E,0x41,0x41,0x41,0x3E,0x00}, // 79 O
{0x7F,0x09,0x09,0x09,0x06,0x00}, // 80 P
{0x3E,0x41,0x51,0x21,0x5E,0x00}, // 81 Q
{0x7F,0x09,0x19,0x29,0x46,0x00}, // 82 R
{0x46,0x49,0x49,0x49,0x31,0x00}, // 83 S
{0x01,0x01,0x7F,0x01,0x01,0x00}, // 84 T
{0x3F,0x40,0x40,0x40,0x3F,0x00}, // 85 U
{0x1F,0x20,0x40,0x20,0x1F,0x00}, // 86 V
{0x3F,0x40,0x38,0x40,0x3F,0x00}, // 87 W
{0x63,0x14,0x08,0x14,0x63,0x00}, // 88 X
{0x07,0x08,0x70,0x08,0x07,0x00}, // 89 Y
{0x61,0x51,0x49,0x45,0x43,0x00}, // 90 Z
{0x00,0x7F,0x41,0x41,0x00,0x00}, // 91 [
{0x02,0x04,0x08,0x10,0x20,0x00}, // 92 backslash
{0x00,0x41,0x41,0x7F,0x00,0x00}, // 93 ]
{0x04,0x02,0x01,0x02,0x04,0x00}, // 94 ^
{0x40,0x40,0x40,0x40,0x40,0x00}, // 95 _
{0x00,0x01,0x02,0x04,0x00,0x00}, // 96 `
{0x20,0x54,0x54,0x54,0x78,0x00}, // 97 a
{0x7F,0x48,0x44,0x44,0x38,0x00}, // 98 b
{0x38,0x44,0x44,0x44,0x20,0x00}, // 99 c
{0x38,0x44,0x44,0x48,0x7F,0x00}, //100 d
{0x38,0x54,0x54,0x54,0x18,0x00}, //101 e
{0x08,0x7E,0x09,0x01,0x02,0x00}, //102 f
{0x0C,0x52,0x52,0x52,0x3E,0x00}, //103 g
{0x7F,0x08,0x04,0x04,0x78,0x00}, //104 h
{0x00,0x44,0x7D,0x40,0x00,0x00}, //105 i
{0x20,0x40,0x44,0x3D,0x00,0x00}, //106 j
{0x7F,0x10,0x28,0x44,0x00,0x00}, //107 k
{0x00,0x41,0x7F,0x40,0x00,0x00}, //108 l
{0x7C,0x04,0x18,0x04,0x78,0x00}, //109 m
{0x7C,0x08,0x04,0x04,0x78,0x00}, //110 n
{0x38,0x44,0x44,0x44,0x38,0x00}, //111 o
{0x7C,0x14,0x14,0x14,0x08,0x00}, //112 p
{0x08,0x14,0x14,0x18,0x7C,0x00}, //113 q
{0x7C,0x08,0x04,0x04,0x08,0x00}, //114 r
{0x48,0x54,0x54,0x54,0x20,0x00}, //115 s
{0x04,0x3F,0x44,0x40,0x20,0x00}, //116 t
{0x3C,0x40,0x40,0x20,0x7C,0x00}, //117 u
{0x1C,0x20,0x40,0x20,0x1C,0x00}, //118 v
{0x3C,0x40,0x30,0x40,0x3C,0x00}, //119 w
{0x44,0x28,0x10,0x28,0x44,0x00}, //120 x
{0x0C,0x50,0x50,0x50,0x3C,0x00}, //121 y
{0x44,0x64,0x54,0x4C,0x44,0x00}, //122 z
{0x00,0x08,0x36,0x41,0x00,0x00}, //123 {
{0x00,0x00,0x7F,0x00,0x00,0x00}, //124 |
{0x00,0x41,0x36,0x08,0x00,0x00}, //125 }
{0x02,0x01,0x02,0x04,0x02,0x00}, //126 ~
{0x7F,0x41,0x41,0x41,0x7F,0x00}  //127 DEL
};
#define FONT6X8_WIDTH 6
#define FONT6X8_FIRST 32
#define FONT6X8_LAST  127

#define FONT6X8_WIDTH 6
#define FONT6X8_FIRST 32
#define FONT6X8_LAST  127

esp_err_t oled_draw_text(uint8_t x, uint8_t page, const char *text)
{
    if (!s_dev || !text) return ESP_ERR_INVALID_STATE;
    if (page > 7 || x >= 128) return ESP_ERR_INVALID_ARG;

    while (*text && x < 128) {
        unsigned char c = (unsigned char)*text;
        if (c < FONT6X8_FIRST || c >= FONT6X8_LAST)
            c = '?'; // fallback for unsupported chars

        const uint8_t *glyph = font6x8[c - FONT6X8_FIRST];
        // Set cursor: page + column
        uint8_t cmds[] = { 0xB0 | page, (uint8_t)(x & 0x0F), (uint8_t)(0x10 | (x >> 4)) };
        ESP_RETURN_ON_ERROR(oled_write_cmds(cmds, sizeof(cmds)), TAG, "set pos");

        // Write glyph data (6 bytes)
        ESP_RETURN_ON_ERROR(oled_write_data(glyph, FONT6X8_WIDTH), TAG, "glyph");
        x += FONT6X8_WIDTH;
        ++text;
    }
    return ESP_OK;
}
